<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Werkzeug Documentation</title>
    <link rel="stylesheet" href="_static/style.css" type="text/css">
    <link rel="stylesheet" href="_static/print.css" type="text/css" media="print">
    <link rel="stylesheet" href="_static/pygments.css" type="text/css">
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:   '',
        VERSION:    '0.5.1dev'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/interface.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/werkzeug.js"></script>
    <link rel="contents" title="Global table of contents" href="contents.html">
    <link rel="index" title="Global index" href="genindex.html">
    <link rel="search" title="Search" href="search.html">
    <link rel="top" title="Werkzeug v0.5.1dev documentation" href="index.html">
    <link rel="next" title="Context Locals" href="local.html">
    <link rel="prev" title="Wrappers" href="wrappers.html">
    
  </head>
  <body>
    <div class="page">
      <div class="header">
        <h1 class="heading"><a href="index.html"
          title="back to the documentation overview"><span>Werkzeug</span></a></h1>
      </div>
      <ul class="navigation">
        <li class="indexlink"><a href="index.html">Overview</a></li>
        <li><a href="wrappers.html">&laquo; Wrappers</a></li>
        <li class="active"><a href="">URL Routing</a></li>
        <li><a href="local.html">Context Locals &raquo;</a></li>
      </ul>
      <div class="body">
        <div id="toc">
          <h3>Table Of Contents</h3>
          <div class="inner"><ul>
<li><a class="reference external" href="">URL Routing</a><ul>
<li><a class="reference external" href="#quickstart">Quickstart</a></li>
<li><a class="reference external" href="#rule-format">Rule Format</a></li>
<li><a class="reference external" href="#builtin-converters">Builtin Converters</a></li>
<li><a class="reference external" href="#maps-rules-and-adapters">Maps, Rules and Adapters</a></li>
<li><a class="reference external" href="#rule-factories">Rule Factories</a></li>
<li><a class="reference external" href="#rule-templates">Rule Templates</a></li>
<li><a class="reference external" href="#custom-converters">Custom Converters</a></li>
</ul>
</li>
</ul>
</div>
        </div>
        
  <div class="section" id="module-werkzeug.routing">
<span id="routing"></span><h1>URL Routing<a class="headerlink" href="#module-werkzeug.routing" title="Permalink to this headline">¶</a></h1>
<p>When it comes to combining multiple controller or view functions (however
you want to call them), you need a dispatcher.  A simple way would be
applying regular expression tests on <tt class="docutils literal"><span class="pre">PATH_INFO</span></tt> and call registered
callback functions that return the value.</p>
<p>Werkzeug provides a much more powerful system, similar to <a class="reference external" href="http://routes.groovie.org/">Routes</a>.  All the
objects mentioned on this page must be imported from <tt class="xref docutils literal"><span class="pre">werkzeug.routing</span></tt>, not
from <a title="" class="reference external" href="wrappers.html#module-werkzeug"><tt class="xref docutils literal"><span class="pre">werkzeug</span></tt></a>!</p>
<div class="section" id="quickstart">
<h2>Quickstart<a class="headerlink" href="#quickstart" title="Permalink to this headline">¶</a></h2>
<p>Here a simple example which could be the URL definition for a blog:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.routing</span> <span class="kn">import</span> <span class="n">Map</span><span class="p">,</span> <span class="n">Rule</span><span class="p">,</span> <span class="n">NotFound</span><span class="p">,</span> <span class="n">RequestRedirect</span>

<span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/index&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;int:year&gt;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/archive&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;int:year&gt;/&lt;int:month&gt;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/archive&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/archive&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;int:year&gt;/&lt;int:month&gt;/&lt;int:day&gt;/&lt;slug&gt;&#39;</span><span class="p">,</span>
         <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/show_post&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/about&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/about_me&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/feeds/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/feeds&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/feeds/&lt;feed_name&gt;.rss&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/show_feed&#39;</span><span class="p">)</span>
<span class="p">])</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="n">url_map</span><span class="o">.</span><span class="n">bind_to_environ</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">endpoint</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">urls</span><span class="o">.</span><span class="n">match</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">HTTPException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s">&#39;text/plain&#39;</span><span class="p">)])</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">&#39;Rule points to </span><span class="si">%r</span><span class="s"> with arguments </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">args</span><span class="p">)]</span>
</pre></div>
</div>
<p>So what does that do?  First of all we create a new <a title="werkzeug.routing.Map" class="reference internal" href="#werkzeug.routing.Map"><tt class="xref docutils literal"><span class="pre">Map</span></tt></a> which stores
a bunch of URL rules.  Then we pass it a list of <a title="werkzeug.routing.Rule" class="reference internal" href="#werkzeug.routing.Rule"><tt class="xref docutils literal"><span class="pre">Rule</span></tt></a> objects.</p>
<p>Each <a title="werkzeug.routing.Rule" class="reference internal" href="#werkzeug.routing.Rule"><tt class="xref docutils literal"><span class="pre">Rule</span></tt></a> object is instantiated with a string that represents a rule
and an endpoint which will be the alias for what view the rule represents.
Multiple rules can have the same endpoint but should have different arguments
to allow URL construction.</p>
<p>The format for the URL rules is straightforward, but explained in detail below.</p>
<p>Inside the WSGI application we bind the url_map to the current request which will
return a new <a title="werkzeug.routing.MapAdapter" class="reference internal" href="#werkzeug.routing.MapAdapter"><tt class="xref docutils literal"><span class="pre">MapAdapter</span></tt></a>.  This url_map adapter can then be used to match
or build domains for the current request.</p>
<p>The <a title="werkzeug.routing.MapAdapter.match" class="reference internal" href="#werkzeug.routing.MapAdapter.match"><tt class="xref docutils literal"><span class="pre">MapAdapter.match</span></tt></a> method can then either return a tuple in the form
<tt class="docutils literal"><span class="pre">(endpoint,</span> <span class="pre">args)</span></tt> or raise one of the three exceptions
<a title="werkzeug.exceptions.NotFound" class="reference external" href="exceptions.html#werkzeug.exceptions.NotFound"><tt class="xref docutils literal"><span class="pre">NotFound</span></tt></a>, <a title="werkzeug.exceptions.MethodNotAllowed" class="reference external" href="exceptions.html#werkzeug.exceptions.MethodNotAllowed"><tt class="xref docutils literal"><span class="pre">MethodNotAllowed</span></tt></a>,
or <tt class="xref docutils literal"><span class="pre">RequestRedirect</span></tt>.  For more details about those
exceptions have a look at the documentation of the <a title="werkzeug.routing.MapAdapter.match" class="reference internal" href="#werkzeug.routing.MapAdapter.match"><tt class="xref docutils literal"><span class="pre">MapAdapter.match</span></tt></a> method.</p>
</div>
<div class="section" id="rule-format">
<h2>Rule Format<a class="headerlink" href="#rule-format" title="Permalink to this headline">¶</a></h2>
<p>Rule strings basically are just normal URL paths with placeholders in the
format <tt class="docutils literal"><span class="pre">&lt;converter(arguments):name&gt;</span></tt>, where converter and the arguments
are optional.  If no converter is defined, the <cite>default</cite> converter is used
(which means <cite>string</cite> in the normal configuration).</p>
<p>URL rules that end with a slash are branch URLs, others are leaves.  If you
have <cite>strict_slashes</cite> enabled (which is the default), all branch URLs that are
visited without a trailing slash will trigger a redirect to the same URL with
that slash appended.</p>
<p>The list of converters can be extended, the default converters are explained
below.</p>
</div>
<div class="section" id="builtin-converters">
<h2>Builtin Converters<a class="headerlink" href="#builtin-converters" title="Permalink to this headline">¶</a></h2>
<p>Here a list of converters that come with Werkzeug:</p>
<dl class="class">
<dt id="werkzeug.routing.UnicodeConverter">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">UnicodeConverter</tt><big>(</big><em>map</em>, <em>minlength=1</em>, <em>maxlength=None</em>, <em>length=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.UnicodeConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>This converter is the default converter and accepts any string but
only one one path segment.  Thus the string can not include a slash.</p>
<p>This is the default validator.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/pages/&lt;page&gt;&#39;</span><span class="p">),</span>
<span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;string(length=2):lang_code&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>map</em> &#8211; the <a title="werkzeug.routing.Map" class="reference internal" href="#werkzeug.routing.Map"><tt class="xref docutils literal"><span class="pre">Map</span></tt></a>.</li>
<li><em>minlength</em> &#8211; the minimum length of the string.  Must be greater
or equal 1.</li>
<li><em>maxlength</em> &#8211; the maximum length of the string.</li>
<li><em>length</em> &#8211; the exact length of the string.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.PathConverter">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">PathConverter</tt><big>(</big><em>map</em><big>)</big><a class="headerlink" href="#werkzeug.routing.PathConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like the default <a title="werkzeug.routing.UnicodeConverter" class="reference internal" href="#werkzeug.routing.UnicodeConverter"><tt class="xref docutils literal"><span class="pre">UnicodeConverter</span></tt></a>, but it also matches
slashes.  This is useful for wikis and similar applications:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;path:wikipage&gt;&#39;</span><span class="p">)</span>
<span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;path:wikipage&gt;/edit&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>map</em> &#8211; the <a title="werkzeug.routing.Map" class="reference internal" href="#werkzeug.routing.Map"><tt class="xref docutils literal"><span class="pre">Map</span></tt></a>.</li>
<li><em>minlength</em> &#8211; the minimum length of the string.  Must be greater
or equal 1.</li>
<li><em>maxlength</em> &#8211; the maximum length of the string.</li>
<li><em>length</em> &#8211; the exact length of the string.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.AnyConverter">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">AnyConverter</tt><big>(</big><em>map</em>, <em>*items</em><big>)</big><a class="headerlink" href="#werkzeug.routing.AnyConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>Matches one of the items provided.  Items can either be Python
identifiers or unicode strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&lt;any(about, help, imprint, u&quot;class&quot;):page_name&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>map</em> &#8211; the <a title="werkzeug.routing.Map" class="reference internal" href="#werkzeug.routing.Map"><tt class="xref docutils literal"><span class="pre">Map</span></tt></a>.</li>
<li><em>items</em> &#8211; this function accepts the possible items as positional
arguments.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.IntegerConverter">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">IntegerConverter</tt><big>(</big><em>map</em>, <em>fixed_digits=0</em>, <em>min=None</em>, <em>max=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.IntegerConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>This converter only accepts integer values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/page/&lt;int:page&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This converter does not support negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>map</em> &#8211; the <a title="werkzeug.routing.Map" class="reference internal" href="#werkzeug.routing.Map"><tt class="xref docutils literal"><span class="pre">Map</span></tt></a>.</li>
<li><em>fixed_digits</em> &#8211; the number of fixed digits in the URL.  If you set
this to <tt class="docutils literal"><span class="pre">4</span></tt> for example, the application will
only match if the url looks like <tt class="docutils literal"><span class="pre">/0001/</span></tt>.  The
default is variable length.</li>
<li><em>min</em> &#8211; the minimal value.</li>
<li><em>max</em> &#8211; the maximal value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.FloatConverter">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">FloatConverter</tt><big>(</big><em>map</em>, <em>min=None</em>, <em>max=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.FloatConverter" title="Permalink to this definition">¶</a></dt>
<dd><p>This converter only accepts floating point values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/probability/&lt;float:probability&gt;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This converter does not support negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>map</em> &#8211; the <a title="werkzeug.routing.Map" class="reference internal" href="#werkzeug.routing.Map"><tt class="xref docutils literal"><span class="pre">Map</span></tt></a>.</li>
<li><em>min</em> &#8211; the minimal value.</li>
<li><em>max</em> &#8211; the maximal value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<div class="admonition-important admonition ">
<p class="first admonition-title">Important</p>
<p>Werkzeug evaluates converter arguments as if they are Python method calls.
Thus, you should <strong>never</strong> create rules from user submitted data since
they could insert arbitrary Python code in the parameters part.</p>
<p>As a matter of fact this is a legal definition and sets fixed_digits to 2:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/picture/&lt;int(fixed_digits=1 + 1):id&gt;.png&#39;</span><span class="p">,</span>
         <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;view_image&#39;</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<p class="last">However, evaluating Python expressions is currently an implementation
detail and might be unavailable in the future.</p>
</div>
</div>
<div class="section" id="maps-rules-and-adapters">
<h2>Maps, Rules and Adapters<a class="headerlink" href="#maps-rules-and-adapters" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="werkzeug.routing.Map">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">Map</tt><big>(</big><em>rules=None</em>, <em>default_subdomain=''</em>, <em>charset='utf-8'</em>, <em>strict_slashes=True</em>, <em>redirect_defaults=True</em>, <em>converters=None</em>, <em>sort_parameters=False</em>, <em>sort_key=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Map" title="Permalink to this definition">¶</a></dt>
<dd><p>The map class stores all the URL rules and some configuration
parameters.  Some of the configuration values are only stored on the
<cite>Map</cite> instance since those affect all rules, others are just defaults
and can be overridden for each rule.  Note that you have to specify all
arguments besides the <cite>rules</cite> as keywords arguments!</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>rules</em> &#8211; sequence of url rules for this map.</li>
<li><em>default_subdomain</em> &#8211; The default subdomain for rules without a
subdomain defined.</li>
<li><em>charset</em> &#8211; charset of the url. defaults to <tt class="docutils literal"><span class="pre">&quot;utf-8&quot;</span></tt></li>
<li><em>strict_slashes</em> &#8211; Take care of trailing slashes.</li>
<li><em>redirect_defaults</em> &#8211; This will redirect to the default rule if it
wasn&#8217;t visited that way. This helps creating
unique URLs.</li>
<li><em>converters</em> &#8211; A dict of converters that adds additional converters
to the list of converters. If you redefine one
converter this will override the original one.</li>
<li><em>sort_parameters</em> &#8211; If set to <cite>True</cite> the url parameters are sorted.
See <cite>url_encode</cite> for more details.</li>
<li><em>sort_key</em> &#8211; The sort key function for <cite>url_encode</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>
<span class="versionmodified">New in version 0.5: </span><cite>sort_parameters</cite> and <cite>sort_key</cite> was added.</p>
<dl class="method">
<dt id="werkzeug.routing.Map.add">
<tt class="descname">add</tt><big>(</big><em>rulefactory</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Map.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a new rule or factory to the map and bind it.  Requires that the
rule is not bound to another map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>rulefactory</em> &#8211; a <a title="werkzeug.routing.Rule" class="reference internal" href="#werkzeug.routing.Rule"><tt class="xref docutils literal"><span class="pre">Rule</span></tt></a> or <a title="werkzeug.routing.RuleFactory" class="reference internal" href="#werkzeug.routing.RuleFactory"><tt class="xref docutils literal"><span class="pre">RuleFactory</span></tt></a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.Map.bind">
<tt class="descname">bind</tt><big>(</big><em>server_name</em>, <em>script_name=None</em>, <em>subdomain=None</em>, <em>url_scheme='http'</em>, <em>default_method='GET'</em>, <em>path_info=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Map.bind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a title="werkzeug.routing.MapAdapter" class="reference internal" href="#werkzeug.routing.MapAdapter"><tt class="xref docutils literal"><span class="pre">MapAdapter</span></tt></a> with the details specified to the
call.  Note that <cite>script_name</cite> will default to <tt class="docutils literal"><span class="pre">'/'</span></tt> if not further
specified or <cite>None</cite>.  The <cite>server_name</cite> at least is a requirement
because the HTTP RFC requires absolute URLs for redirects and so all
redirect exceptions raised by Werkzeug will contain the full canonical
URL.</p>
<p>If no path_info is passed to <tt class="xref docutils literal"><span class="pre">match</span></tt> it will use the default path
info passed to bind.  While this doesn&#8217;t really make sense for
manual bind calls, it&#8217;s useful if you bind a map to a WSGI
environment which already contains the path info.</p>
<p><cite>subdomain</cite> will default to the <cite>default_subdomain</cite> for this map if
no defined. If there is no <cite>default_subdomain</cite> you cannot use the
subdomain feature.</p>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.Map.bind_to_environ">
<tt class="descname">bind_to_environ</tt><big>(</big><em>environ</em>, <em>server_name=None</em>, <em>subdomain=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Map.bind_to_environ" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a title="werkzeug.routing.Map.bind" class="reference internal" href="#werkzeug.routing.Map.bind"><tt class="xref docutils literal"><span class="pre">bind</span></tt></a> but you can pass it an WSGI environment and it
will fetch the information from that directory.  Note that because of
limitations in the protocol there is no way to get the current
subdomain and real <cite>server_name</cite> from the environment.  If you don&#8217;t
provide it, Werkzeug will use <cite>SERVER_NAME</cite> and <cite>SERVER_PORT</cite> (or
<cite>HTTP_HOST</cite> if provided) as used <cite>server_name</cite> with disabled subdomain
feature.</p>
<p>If <cite>subdomain</cite> is <cite>None</cite> but an environment and a server name is
provided it will calculate the current subdomain automatically.
Example: <cite>server_name</cite> is <tt class="docutils literal"><span class="pre">'example.com'</span></tt> and the <cite>SERVER_NAME</cite>
in the wsgi <cite>environ</cite> is <tt class="docutils literal"><span class="pre">'staging.dev.example.com'</span></tt> the calculated
subdomain will be <tt class="docutils literal"><span class="pre">'staging.dev'</span></tt>.</p>
<p>If the object passed as environ has an environ attribute, the value of
this attribute is used instead.  This allows you to pass request
objects.  Additionally <cite>PATH_INFO</cite> added as a default ot the
<a title="werkzeug.routing.MapAdapter" class="reference internal" href="#werkzeug.routing.MapAdapter"><tt class="xref docutils literal"><span class="pre">MapAdapter</span></tt></a> so that you don&#8217;t have to pass the path info to
the match method.</p>
<p>
<span class="versionmodified">Changed in version 0.5: </span>previously this method accepted a bogus <cite>calculate_subdomain</cite>
parameter that did not have any effect.  It was removed because
of that.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>environ</em> &#8211; a WSGI environment.</li>
<li><em>server_name</em> &#8211; an optional server name hint (see above).</li>
<li><em>subdomain</em> &#8211; optionally the current subdomain (see above).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.Map.is_endpoint_expecting">
<tt class="descname">is_endpoint_expecting</tt><big>(</big><em>endpoint</em>, <em>*arguments</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Map.is_endpoint_expecting" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all rules and check if the endpoint expects
the arguments provided.  This is for example useful if you have
some URLs that expect a language code and others that do not and
you want to wrap the builder a bit so that the current language
code is automatically added if not provided but endpoints expect
it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>endpoint</em> &#8211; the endpoint to check.</li>
<li><em>arguments</em> &#8211; this function accepts one or more arguments
as positional arguments.  Each one of them is
checked.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.Map.iter_rules">
<tt class="descname">iter_rules</tt><big>(</big><em>endpoint=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Map.iter_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over all rules or the rules of an endpoint.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameter:</th><td class="field-body"><em>endpoint</em> &#8211; if provided only the rules for that endpoint
are returned.</td>
</tr>
<tr class="field"><th class="field-name">Returns:</th><td class="field-body">an iterator</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.Map.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#werkzeug.routing.Map.update" title="Permalink to this definition">¶</a></dt>
<dd>Called before matching and building to keep the compiled rules
in the correct order after things changed.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.MapAdapter">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">MapAdapter</tt><big>(</big><em>map</em>, <em>server_name</em>, <em>script_name</em>, <em>subdomain</em>, <em>url_scheme</em>, <em>path_info</em>, <em>default_method</em><big>)</big><a class="headerlink" href="#werkzeug.routing.MapAdapter" title="Permalink to this definition">¶</a></dt>
<dd><p>Returned by <a title="werkzeug.routing.Map.bind" class="reference internal" href="#werkzeug.routing.Map.bind"><tt class="xref docutils literal"><span class="pre">Map.bind</span></tt></a> or <a title="werkzeug.routing.Map.bind_to_environ" class="reference internal" href="#werkzeug.routing.Map.bind_to_environ"><tt class="xref docutils literal"><span class="pre">Map.bind_to_environ</span></tt></a> and does
the URL matching and building based on runtime information.</p>
<dl class="method">
<dt id="werkzeug.routing.MapAdapter.build">
<tt class="descname">build</tt><big>(</big><em>endpoint</em>, <em>values=None</em>, <em>method=None</em>, <em>force_external=False</em><big>)</big><a class="headerlink" href="#werkzeug.routing.MapAdapter.build" title="Permalink to this definition">¶</a></dt>
<dd><p>Building URLs works pretty much the other way round.  Instead of
<cite>match</cite> you call <cite>build</cite> and pass it the endpoint and a dict of
arguments for the placeholders.</p>
<p>The <cite>build</cite> function also accepts an argument called <cite>force_external</cite>
which, if you set it to <cite>True</cite> will force external URLs. Per default
external URLs (include the server name) will only be used if the
target URL is on a different subdomain.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/downloads/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;downloads/index&#39;</span><span class="p">),</span> 
<span class="gp">... </span>    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/downloads/&lt;int:id&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;downloads/show&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;example.com&quot;</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&quot;index&quot;</span><span class="p">,</span> <span class="p">{})</span>
<span class="go">&#39;/&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&quot;downloads/show&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mf">42</span><span class="p">})</span>
<span class="go">&#39;/downloads/42&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&quot;downloads/show&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;id&#39;</span><span class="p">:</span> <span class="mf">42</span><span class="p">},</span> <span class="n">force_external</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="go">&#39;http://example.com/downloads/42&#39;</span>
</pre></div>
</div>
<p>Because URLs cannot contain non ASCII data you will always get
bytestrings back.  Non ASCII characters are urlencoded with the
charset defined on the map instance.</p>
<p>Additional values are converted to unicode and appended to the URL as
URL querystring parameters:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&quot;index&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;q&#39;</span><span class="p">:</span> <span class="s">&#39;My Searchstring&#39;</span><span class="p">})</span>
<span class="go">&#39;/?q=My+Searchstring&#39;</span>
</pre></div>
</div>
<p>If a rule does not exist when building a <cite>BuildError</cite> exception is
raised.</p>
<p>The build method accepts an argument called <cite>method</cite> which allows you
to specify the method you want to have an URL built for if you have
different methods for the same endpoint specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>endpoint</em> &#8211; the endpoint of the URL to build.</li>
<li><em>values</em> &#8211; the values for the URL to build.  Unhandled values are
appended to the URL as query parameters.</li>
<li><em>method</em> &#8211; the HTTP method for the rule if there are different
URLs for different methods on the same endpoint.</li>
<li><em>force_external</em> &#8211; enforce full canonical external URLs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.MapAdapter.dispatch">
<tt class="descname">dispatch</tt><big>(</big><em>view_func</em>, <em>path_info=None</em>, <em>method=None</em>, <em>catch_http_exceptions=False</em><big>)</big><a class="headerlink" href="#werkzeug.routing.MapAdapter.dispatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Does the complete dispatching process.  <cite>view_func</cite> is called with
the endpoint and a dict with the values for the view.  It should
look up the view function, call it, and return a response object
or WSGI application.  http exceptions are not catched by default
so that applications can display nicer error messages by just
catching them by hand.  If you want to stick with the default
error messages you can pass it <tt class="docutils literal"><span class="pre">catch_http_exceptions=True</span></tt> and
it will catch the http exceptions.</p>
<p>Here a small example for the dispatch usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">Request</span><span class="p">,</span> <span class="n">Response</span><span class="p">,</span> <span class="n">responder</span>
<span class="kn">from</span> <span class="nn">werkzeug.routing</span> <span class="kn">import</span> <span class="n">Map</span><span class="p">,</span> <span class="n">Rule</span>

<span class="k">def</span> <span class="nf">on_index</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span><span class="s">&#39;Hello from the index&#39;</span><span class="p">)</span>

<span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span><span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">)])</span>
<span class="n">views</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;index&#39;</span><span class="p">:</span> <span class="n">on_index</span><span class="p">}</span>

<span class="nd">@responder</span>
<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">request</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="n">urls</span> <span class="o">=</span> <span class="n">url_map</span><span class="o">.</span><span class="n">bind_to_environ</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">urls</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">views</span><span class="p">[</span><span class="n">e</span><span class="p">](</span><span class="n">request</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">),</span>
                         <span class="n">catch_http_exceptions</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Keep in mind that this method might return exception objects, too, so
use <tt class="xref docutils literal"><span class="pre">Response.force_type</span></tt> to get a response object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>view_func</em> &#8211; a function that is called with the endpoint as
first argument and the value dict as second.  Has
to dispatch to the actual view function with this
information.  (see above)</li>
<li><em>path_info</em> &#8211; the path info to use for matching.  Overrides the
path info specified on binding.</li>
<li><em>method</em> &#8211; the HTTP method used for matching.  Overrides the
method specified on binding.</li>
<li><em>catch_http_exceptions</em> &#8211; set to <cite>True</cite> to catch any of the
werkzeug <tt class="xref docutils literal"><span class="pre">HTTPException</span></tt>s.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.MapAdapter.match">
<tt class="descname">match</tt><big>(</big><em>path_info=None</em>, <em>method=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.MapAdapter.match" title="Permalink to this definition">¶</a></dt>
<dd><p>The usage is simple: you just pass the match method the current
path info as well as the method (which defaults to <cite>GET</cite>).  The
following things can then happen:</p>
<ul class="simple">
<li>you receive a <cite>NotFound</cite> exception that indicates that no URL is
matching.  A <cite>NotFound</cite> exception is also a WSGI application you
can call to get a default page not found page (happens to be the
same object as <cite>werkzeug.exceptions.NotFound</cite>)</li>
<li>you receive a <cite>MethodNotAllowed</cite> exception that indicates that there
is a match for this URL but non for the current request method.
This is useful for RESTful applications.</li>
<li>you receive a <cite>RequestRedirect</cite> exception with a <cite>new_url</cite>
attribute.  This exception is used to notify you about a request
Werkzeug requests by your WSGI application.  This is for example the
case if you request <tt class="docutils literal"><span class="pre">/foo</span></tt> although the correct URL is <tt class="docutils literal"><span class="pre">/foo/</span></tt>
You can use the <cite>RequestRedirect</cite> instance as response-like object
similar to all other subclasses of <cite>HTTPException</cite>.</li>
<li>you get a tuple in the form <tt class="docutils literal"><span class="pre">(endpoint,</span> <span class="pre">arguments)</span></tt> when there is
a match.</li>
</ul>
<p>If the path info is not passed to the match method the default path
info of the map is used (defaults to the root URL if not defined
explicitly).</p>
<p>All of the exceptions raised are subclasses of <cite>HTTPException</cite> so they
can be used as WSGI responses.  The will all render generic error or
redirect pages.</p>
<p>Here is a small example for matching:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/downloads/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;downloads/index&#39;</span><span class="p">),</span> 
<span class="gp">... </span>    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/downloads/&lt;int:id&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;downloads/show&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="s">&quot;example.com&quot;</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="s">&quot;GET&quot;</span><span class="p">)</span>
<span class="go">(&#39;index&#39;, {})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;/downloads/42&quot;</span><span class="p">)</span>
<span class="go">(&#39;downloads/show&#39;, {&#39;id&#39;: 42})</span>
</pre></div>
</div>
<p>And here is what happens on redirect and missing URLs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;/downloads&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">RequestRedirect</span>: <span class="n-Identifier">http://example.com/downloads/</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">urls</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;/missing&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="nc">NotFound</span>: <span class="n-Identifier">404 Not Found</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>path_info</em> &#8211; the path info to use for matching.  Overrides the
path info specified on binding.</li>
<li><em>method</em> &#8211; the HTTP method used for matching.  Overrides the
method specified on binding.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="werkzeug.routing.MapAdapter.test">
<tt class="descname">test</tt><big>(</big><em>path_info=None</em>, <em>method=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.MapAdapter.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if a rule would match.  Works like <cite>match</cite> but returns <cite>True</cite>
if the URL matches, or <cite>False</cite> if it does not exist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><em>path_info</em> &#8211; the path info to use for matching.  Overrides the
path info specified on binding.</li>
<li><em>method</em> &#8211; the HTTP method used for matching.  Overrides the
method specified on binding.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.Rule">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">Rule</tt><big>(</big><em>string</em>, <em>defaults=None</em>, <em>subdomain=None</em>, <em>methods=None</em>, <em>build_only=False</em>, <em>endpoint=None</em>, <em>strict_slashes=None</em>, <em>redirect_to=None</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Rule" title="Permalink to this definition">¶</a></dt>
<dd><p>A Rule represents one URL pattern.  There are some options for <cite>Rule</cite>
that change the way it behaves and are passed to the <cite>Rule</cite> constructor.
Note that besides the rule-string all arguments <em>must</em> be keyword arguments
in order to not break the application on Werkzeug upgrades.</p>
<dl class="docutils">
<dt><cite>string</cite></dt>
<dd><p class="first">Rule strings basically are just normal URL paths with placeholders in
the format <tt class="docutils literal"><span class="pre">&lt;converter(arguments):name&gt;</span></tt> where the converter and the
arguments are optional.  If no converter is defined the <cite>default</cite>
converter is used which means <cite>string</cite> in the normal configuration.</p>
<p>URL rules that end with a slash are branch URLs, others are leaves.
If you have <cite>strict_slashes</cite> enabled (which is the default), all
branch URLs that are matched without a trailing slash will trigger a
redirect to the same URL with the missing slash appended.</p>
<p class="last">The converters are defined on the <cite>Map</cite>.</p>
</dd>
<dt><cite>endpoint</cite></dt>
<dd>The endpoint for this rule. This can be anything. A reference to a
function, a string, a number etc.  The preferred way is using a string
as because the endpoint is used for URL generation.</dd>
<dt><cite>defaults</cite></dt>
<dd><p class="first">An optional dict with defaults for other rules with the same endpoint.
This is a bit tricky but useful if you want to have unique URLs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/all/&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;page&#39;</span><span class="p">:</span> <span class="mf">1</span><span class="p">},</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;all_entries&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/all/page/&lt;int:page&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;all_entries&#39;</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<p class="last">If a user now visits <tt class="docutils literal"><span class="pre">http://example.com/all/page/1</span></tt> he will be
redirected to <tt class="docutils literal"><span class="pre">http://example.com/all/</span></tt>.  If <cite>redirect_defaults</cite> is
disabled on the <cite>Map</cite> instance this will only affect the URL
generation.</p>
</dd>
<dt><cite>subdomain</cite></dt>
<dd><p class="first">The subdomain rule string for this rule. If not specified the rule
only matches for the <cite>default_subdomain</cite> of the map.  If the map is
not bound to a subdomain this feature is disabled.</p>
<p>Can be useful if you want to have user profiles on different subdomains
and all subdomains are forwarded to your application:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">subdomain</span><span class="o">=</span><span class="s">&#39;&lt;username&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;user/homepage&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/stats&#39;</span><span class="p">,</span> <span class="n">subdomain</span><span class="o">=</span><span class="s">&#39;&lt;username&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;user/stats&#39;</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
</dd>
<dt><cite>methods</cite></dt>
<dd>A sequence of http methods this rule applies to.  If not specified, all
methods are allowed. For example this can be useful if you want different
endpoints for <cite>POST</cite> and <cite>GET</cite>.  If methods are defined and the path
matches but the method matched against is not in this list or in the
list of another rule for that path the error raised is of the type
<cite>MethodNotAllowed</cite> rather than <cite>NotFound</cite>.</dd>
<dt><cite>strict_slashes</cite></dt>
<dd>Override the <cite>Map</cite> setting for <cite>strict_slashes</cite> only for this rule. If
not specified the <cite>Map</cite> setting is used.</dd>
<dt><cite>build_only</cite></dt>
<dd>Set this to True and the rule will never match but will create a URL
that can be build. This is useful if you have resources on a subdomain
or folder that are not handled by the WSGI application (like static data)</dd>
<dt><cite>redirect_to</cite></dt>
<dd><p class="first">If given this must be either a string or callable.  In case of a
callable it&#8217;s called with the url adapter that triggered the match and
the values of the URL as keyword arguments and has to return the target
for the redirect, otherwise it has to be a string with placeholders in
rule syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">foo_with_slug</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
    <span class="c"># ask the database for the slug for the old id.  this of</span>
    <span class="c"># course has nothing to do with werkzeug.</span>
    <span class="k">return</span> <span class="s">&#39;foo/&#39;</span> <span class="o">+</span> <span class="n">Foo</span><span class="o">.</span><span class="n">get_slug_for_id</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

<span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/foo/&lt;slug&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/some/old/url/&lt;slug&gt;&#39;</span><span class="p">,</span> <span class="n">redirect_to</span><span class="o">=</span><span class="s">&#39;foo/&lt;slug&gt;&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/other/old/url/&lt;int:id&gt;&#39;</span><span class="p">,</span> <span class="n">redirect_to</span><span class="o">=</span><span class="n">foo_with_slug</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<p>When the rule is matched the routing system will raise a
<cite>RequestRedirect</cite> exception with the target for the redirect.</p>
<p class="last">Keep in mind that the URL will be joined against the URL root of the
script so don&#8217;t use a leading slash on the target URL unless you
really mean root of that domain.</p>
</dd>
</dl>
<dl class="method">
<dt id="werkzeug.routing.Rule.empty">
<tt class="descname">empty</tt><big>(</big><big>)</big><a class="headerlink" href="#werkzeug.routing.Rule.empty" title="Permalink to this definition">¶</a></dt>
<dd>Return an unbound copy of this rule.  This can be useful if you
want to reuse an already bound URL for another map.</dd></dl>

</dd></dl>

</div>
<div class="section" id="rule-factories">
<h2>Rule Factories<a class="headerlink" href="#rule-factories" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="werkzeug.routing.RuleFactory">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">RuleFactory</tt><a class="headerlink" href="#werkzeug.routing.RuleFactory" title="Permalink to this definition">¶</a></dt>
<dd><p>As soon as you have more complex URL setups it&#8217;s a good idea to use rule
factories to avoid repetitive tasks.  Some of them are builtin, others can
be added by subclassing <cite>RuleFactory</cite> and overriding <cite>get_rules</cite>.</p>
<dl class="method">
<dt id="werkzeug.routing.RuleFactory.get_rules">
<tt class="descname">get_rules</tt><big>(</big><em>map</em><big>)</big><a class="headerlink" href="#werkzeug.routing.RuleFactory.get_rules" title="Permalink to this definition">¶</a></dt>
<dd>Subclasses of <cite>RuleFactory</cite> have to override this method and return
an iterable of rules.</dd></dl>

</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.Subdomain">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">Subdomain</tt><big>(</big><em>subdomain</em>, <em>rules</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Subdomain" title="Permalink to this definition">¶</a></dt>
<dd><p>All URLs provided by this factory have the subdomain set to a
specific domain. For example if you want to use the subdomain for
the current language this can be a good setup:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;#select_language&#39;</span><span class="p">),</span>
    <span class="n">Subdomain</span><span class="p">(</span><span class="s">&#39;&lt;string(length=2):lang_code&gt;&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">),</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/about&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;about&#39;</span><span class="p">),</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/help&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;help&#39;</span><span class="p">)</span>
    <span class="p">])</span>
<span class="p">])</span>
</pre></div>
</div>
<p>All the rules except for the <tt class="docutils literal"><span class="pre">'#select_language'</span></tt> endpoint will now
listen on a two letter long subdomain that helds the language code
for the current request.</p>
</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.Submount">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">Submount</tt><big>(</big><em>path</em>, <em>rules</em><big>)</big><a class="headerlink" href="#werkzeug.routing.Submount" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <cite>Subdomain</cite> but prefixes the URL rule with a given string:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">),</span>
    <span class="n">Submount</span><span class="p">(</span><span class="s">&#39;/blog&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/index&#39;</span><span class="p">),</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/entry/&lt;entry_slug&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;blog/show&#39;</span><span class="p">)</span>
    <span class="p">])</span>
<span class="p">])</span>
</pre></div>
</div>
<p>Now the rule <tt class="docutils literal"><span class="pre">'blog/show'</span></tt> matches <tt class="docutils literal"><span class="pre">/blog/entry/&lt;entry_slug&gt;</span></tt>.</p>
</dd></dl>

<dl class="class">
<dt id="werkzeug.routing.EndpointPrefix">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">EndpointPrefix</tt><big>(</big><em>prefix</em>, <em>rules</em><big>)</big><a class="headerlink" href="#werkzeug.routing.EndpointPrefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Prefixes all endpoints (which must be strings for this factory) with
another string. This can be useful for sub applications:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">),</span>
    <span class="n">EndpointPrefix</span><span class="p">(</span><span class="s">&#39;blog/&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">Submount</span><span class="p">(</span><span class="s">&#39;/blog&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;index&#39;</span><span class="p">),</span>
        <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/entry/&lt;entry_slug&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;show&#39;</span><span class="p">)</span>
    <span class="p">])])</span>
<span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rule-templates">
<h2>Rule Templates<a class="headerlink" href="#rule-templates" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="werkzeug.routing.RuleTemplate">
<em class="property">
class </em><tt class="descclassname">werkzeug.routing.</tt><tt class="descname">RuleTemplate</tt><big>(</big><em>rules</em><big>)</big><a class="headerlink" href="#werkzeug.routing.RuleTemplate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns copies of the rules wrapped and expands string templates in
the endpoint, rule, defaults or subdomain sections.</p>
<p>Here a small example for such a rule template:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">werkzeug.routing</span> <span class="kn">import</span> <span class="n">Map</span><span class="p">,</span> <span class="n">Rule</span><span class="p">,</span> <span class="n">RuleTemplate</span>

<span class="n">resource</span> <span class="o">=</span> <span class="n">RuleTemplate</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/$name/&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;$name.list&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/$name/&lt;int:id&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;$name.show&#39;</span><span class="p">)</span>
<span class="p">])</span>

<span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span><span class="n">resource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">),</span> <span class="n">resource</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;page&#39;</span><span class="p">)])</span>
</pre></div>
</div>
<p>When a rule template is called the keyword arguments are used to
replace the placeholders in all the string parameters.</p>
</dd></dl>

</div>
<div class="section" id="custom-converters">
<h2>Custom Converters<a class="headerlink" href="#custom-converters" title="Permalink to this headline">¶</a></h2>
<p>You can easily add custom converters.  The only thing you have to do is to
subclass <tt class="xref docutils literal"><span class="pre">BaseConverter</span></tt> and pass that new converter to the url_map.
A converter has to provide two public methods: <cite>to_python</cite> and <cite>to_url</cite>,
as well as a member that represents a regular expression.  Here is a small
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
<span class="kn">from</span> <span class="nn">werkzeug.routing</span> <span class="kn">import</span> <span class="n">Rule</span><span class="p">,</span> <span class="n">Map</span><span class="p">,</span> <span class="n">BaseConverter</span><span class="p">,</span> <span class="n">ValidationError</span>

<span class="k">class</span> <span class="nc">BooleanConverter</span><span class="p">(</span><span class="n">BaseConverter</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url_map</span><span class="p">,</span> <span class="n">randomify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BooleanConverter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">url_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">randomify</span> <span class="o">=</span> <span class="n">randomify</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regex</span> <span class="o">=</span> <span class="s">&#39;(?:yes|no|maybe)&#39;</span>

    <span class="k">def</span> <span class="nf">to_python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;maybe&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">randomify</span><span class="p">:</span>
                <span class="k">return</span> <span class="ow">not</span> <span class="n">randrange</span><span class="p">(</span><span class="mf">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">==</span> <span class="s">&#39;yes&#39;</span>

    <span class="k">def</span> <span class="nf">to_url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">and</span> <span class="s">&#39;yes&#39;</span> <span class="ow">or</span> <span class="s">&#39;no&#39;</span>

<span class="n">url_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">([</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/vote/&lt;bool:werkzeug_rocks&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;vote&#39;</span><span class="p">),</span>
    <span class="n">Rule</span><span class="p">(</span><span class="s">&#39;/vote/&lt;bool(randomify=True):foo&gt;&#39;</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="s">&#39;foo&#39;</span><span class="p">)</span>
<span class="p">],</span> <span class="n">converters</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;bool&#39;</span><span class="p">:</span> <span class="n">BooleanConverter</span><span class="p">})</span>
</pre></div>
</div>
<p>If you want that converter to be the default converter, name it <tt class="docutils literal"><span class="pre">'default'</span></tt>.</p>
</div>
</div>


        <div style="clear: both"></div>
      </div>
      <div class="footer">
        © Copyright 2008 by the <a href="http://pocoo.org/">Pocoo Team</a>,
        documentation generated by <a href="http://sphinx.pocoo.org/">Sphinx</a>
      </div>
    </div>
  </body>
</html>